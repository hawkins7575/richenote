// ============================================================================
// Îç∞Ïù¥ÌÑ∞ Í∞ÄÏ†∏Ïò§Í∏∞/ÎÇ¥Î≥¥ÎÇ¥Í∏∞ ÏÑúÎπÑÏä§
// ============================================================================

import { supabase } from "./supabase";
import { Property, CreatePropertyData, PropertyStatus } from "@/types";

export interface ImportResult {
  success: number;
  failed: number;
  errors: ImportError[];
  importedProperties: Property[];
}

export interface ImportError {
  row: number;
  field?: string;
  message: string;
  data?: CreatePropertyData;
}

export interface ExportOptions {
  format: "csv" | "excel" | "json";
  includeFields: string[];
  filters?: {
    dateRange?: "all" | "thisMonth" | "lastMonth" | "custom";
    customDateFrom?: string;
    customDateTo?: string;
    propertyStatus?: "all" | PropertyStatus;
    propertyType?: string;
  };
}

/**
 * Îß§Î¨º Îç∞Ïù¥ÌÑ∞ Í∞ÄÏ†∏Ïò§Í∏∞
 */
export const importProperties = async (
  properties: CreatePropertyData[],
  tenantId: string,
  createdBy: string,
): Promise<ImportResult> => {
  const errors: ImportError[] = [];
  const importedProperties: Property[] = [];

  for (let i = 0; i < properties.length; i++) {
    const property = properties[i];

    try {
      // Îç∞Ïù¥ÌÑ∞ Í≤ÄÏ¶ù
      const validationError = validatePropertyData(property, i + 1);
      if (validationError) {
        errors.push(validationError);
        continue;
      }

      // SupabaseÏóê Îß§Î¨º Îç∞Ïù¥ÌÑ∞ ÏÇΩÏûÖ
      const { data, error } = await supabase
        .from("properties")
        .insert({
          tenant_id: tenantId,
          created_by: createdBy,
          ...property,
          view_count: 0,
          inquiry_count: 0,
          is_featured: false,
          is_urgent: false,
          is_favorite: false,
        })
        .select()
        .single();

      if (error) {
        errors.push({
          row: i + 1,
          message: `Îç∞Ïù¥ÌÑ∞Î≤†Ïù¥Ïä§ Ïò§Î•ò: ${error.message}`,
          data: property,
        });
        continue;
      }

      if (data) {
        importedProperties.push(data as Property);
      }
    } catch (err) {
      errors.push({
        row: i + 1,
        message: `Ï≤òÎ¶¨ Ï§ë Ïò§Î•ò: ${err instanceof Error ? err.message : "Ïïå Ïàò ÏóÜÎäî Ïò§Î•ò"}`,
        data: property,
      });
    }
  }

  return {
    success: importedProperties.length,
    failed: properties.length - importedProperties.length,
    errors,
    importedProperties,
  };
};

/**
 * Îß§Î¨º Îç∞Ïù¥ÌÑ∞ ÎÇ¥Î≥¥ÎÇ¥Í∏∞
 */
export const exportProperties = async (
  tenantId: string,
  options: ExportOptions,
): Promise<Property[]> => {
  console.log("üîç ÎÇ¥Î≥¥ÎÇ¥Í∏∞ ÏöîÏ≤≠:", { tenantId, options });

  let query = supabase.from("properties").select("*").eq("tenant_id", tenantId);

  // Î®ºÏ†Ä Ï†ÑÏ≤¥ Îß§Î¨º Ïàò ÌôïÏù∏
  const { data: allProperties } = await supabase
    .from("properties")
    .select("*")
    .eq("tenant_id", tenantId);

  console.log("üìä Ï†ÑÏ≤¥ Îß§Î¨º Ïàò:", allProperties?.length || 0);
  console.log("üìä Ï†ÑÏ≤¥ Îß§Î¨º ÏÉòÌîå:", allProperties?.slice(0, 3));

  // ÌïÑÌÑ∞ Ï†ÅÏö©
  if (options.filters) {
    const { filters } = options;
    console.log("üîß Ï†ÅÏö©Ìï† ÌïÑÌÑ∞:", filters);

    // Îß§Î¨º ÏÉÅÌÉú ÌïÑÌÑ∞
    if (filters.propertyStatus && filters.propertyStatus !== "all") {
      console.log("üè∑Ô∏è ÏÉÅÌÉú ÌïÑÌÑ∞ Ï†ÅÏö©:", filters.propertyStatus);
      query = query.eq("status", filters.propertyStatus);
    }

    // Îß§Î¨º Ïú†Ìòï ÌïÑÌÑ∞
    if (filters.propertyType && filters.propertyType !== "all") {
      console.log("üè† Ïú†Ìòï ÌïÑÌÑ∞ Ï†ÅÏö©:", filters.propertyType);
      query = query.eq("type", filters.propertyType);
    }

    // ÎÇ†Ïßú Î≤îÏúÑ ÌïÑÌÑ∞
    if (filters.dateRange && filters.dateRange !== "all") {
      const now = new Date();
      console.log("üìÖ ÎÇ†Ïßú ÌïÑÌÑ∞ Ï†ÅÏö©:", filters.dateRange);

      switch (filters.dateRange) {
        case "thisMonth":
          const thisMonthStart = new Date(now.getFullYear(), now.getMonth(), 1);
          console.log("üìÖ Ïù¥Î≤à Îã¨ ÏãúÏûë:", thisMonthStart.toISOString());
          query = query.gte("created_at", thisMonthStart.toISOString());
          break;

        case "lastMonth":
          const lastMonthStart = new Date(
            now.getFullYear(),
            now.getMonth() - 1,
            1,
          );
          const lastMonthEnd = new Date(now.getFullYear(), now.getMonth(), 0);
          console.log("üìÖ ÏßÄÎÇú Îã¨:", lastMonthStart.toISOString(), "~", lastMonthEnd.toISOString());
          query = query
            .gte("created_at", lastMonthStart.toISOString())
            .lte("created_at", lastMonthEnd.toISOString());
          break;

        case "custom":
          if (filters.customDateFrom) {
            console.log("üìÖ ÏÇ¨Ïö©Ïûê ÏßÄÏ†ï ÏãúÏûë:", filters.customDateFrom);
            query = query.gte("created_at", filters.customDateFrom);
          }
          if (filters.customDateTo) {
            const endDate = filters.customDateTo + "T23:59:59";
            console.log("üìÖ ÏÇ¨Ïö©Ïûê ÏßÄÏ†ï ÎÅù:", endDate);
            query = query.lte("created_at", endDate);
          }
          break;
      }
    }
  }

  // ÏÉùÏÑ±Ïùº Í∏∞Ï§Ä ÎÇ¥Î¶ºÏ∞®Ïàú Ï†ïÎ†¨
  query = query.order("created_at", { ascending: false });

  const { data, error } = await query;

  console.log("üìä ÌïÑÌÑ∞ÎßÅÎêú Îß§Î¨º Ïàò:", data?.length || 0);
  console.log("üìä ÌïÑÌÑ∞ÎßÅÎêú Îß§Î¨º ÏÉòÌîå:", data?.slice(0, 3));

  if (error) {
    console.error("‚ùå Îç∞Ïù¥ÌÑ∞Î≤†Ïù¥Ïä§ Ïò§Î•ò:", error);
    throw new Error(`Îç∞Ïù¥ÌÑ∞ ÎÇ¥Î≥¥ÎÇ¥Í∏∞ Ïã§Ìå®: ${error.message}`);
  }

  return data || [];
};

/**
 * CSV ÌòïÏãùÏúºÎ°ú Îç∞Ïù¥ÌÑ∞ Î≥ÄÌôò
 */
export const formatAsCSV = (
  properties: Property[],
  includeFields: string[],
): string => {
  const fieldLabels: Record<string, string> = {
    title: "Îß§Î¨ºÎ™Ö",
    type: "Îß§Î¨ºÏú†Ìòï",
    transaction_type: "Í±∞ÎûòÏú†Ìòï",
    status: "Îß§Î¨ºÏÉÅÌÉú",
    address: "Ï£ºÏÜå",
    detailed_address: "ÏÉÅÏÑ∏Ï£ºÏÜå",
    area: "Î©¥Ï†Å(m¬≤)",
    floor: "Ï∏µ",
    total_floors: "Ï¥ùÏ∏µÏàò",
    rooms: "Î∞©Ïàò",
    bathrooms: "ÌôîÏû•Ïã§Ïàò",
    parking: "Ï£ºÏ∞®Í∞ÄÎä•",
    elevator: "ÏóòÎ¶¨Î≤†Ïù¥ÌÑ∞",
    price: "Îß§Îß§Í∞Ä(ÎßåÏõê)",
    deposit: "Î≥¥Ï¶ùÍ∏à(ÎßåÏõê)",
    monthly_rent: "ÏõîÏÑ∏(ÎßåÏõê)",
    maintenance_fee: "Í¥ÄÎ¶¨ÎπÑ(ÎßåÏõê)",
    landlord_name: "ÏûÑÎåÄÏù∏Î™Ö",
    landlord_phone: "ÏûÑÎåÄÏù∏ Ïó∞ÎùΩÏ≤ò",
    landlord_email: "ÏûÑÎåÄÏù∏ Ïù¥Î©îÏùº",
    exit_date: "Ìá¥Ïã§ÎÇ†Ïßú",
    available_from: "ÏûÖÏ£ºÍ∞ÄÎä•Ïùº",
    description: "ÏÑ§Î™Ö",
    view_count: "Ï°∞ÌöåÏàò",
    inquiry_count: "Î¨∏ÏùòÏàò",
    created_at: "Îì±Î°ùÏùº",
    updated_at: "ÏàòÏ†ïÏùº",
  };

  // Ìó§Îçî ÏÉùÏÑ±
  const headers = includeFields.map((field) => fieldLabels[field] || field);

  // Îç∞Ïù¥ÌÑ∞ Ìñâ ÏÉùÏÑ±
  const rows = properties.map((property) => {
    return includeFields.map((field) => {
      const value = formatFieldValue(property, field);
      // CSVÏóêÏÑú ÌäπÏàòÎ¨∏Ïûê Ïù¥Ïä§ÏºÄÏù¥ÌîÑ
      return `"${String(value).replace(/"/g, '""')}"`;
    });
  });

  // CSV Î¨∏ÏûêÏó¥ ÏÉùÏÑ±
  return [headers, ...rows].map((row) => row.join(",")).join("\n");
};

/**
 * JSON ÌòïÏãùÏúºÎ°ú Îç∞Ïù¥ÌÑ∞ Î≥ÄÌôò
 */
export const formatAsJSON = (
  properties: Property[],
  includeFields: string[],
): string => {
  const fieldLabels: Record<string, string> = {
    title: "Îß§Î¨ºÎ™Ö",
    type: "Îß§Î¨ºÏú†Ìòï",
    transaction_type: "Í±∞ÎûòÏú†Ìòï",
    status: "Îß§Î¨ºÏÉÅÌÉú",
    address: "Ï£ºÏÜå",
    detailed_address: "ÏÉÅÏÑ∏Ï£ºÏÜå",
    area: "Î©¥Ï†Å",
    floor: "Ï∏µ",
    total_floors: "Ï¥ùÏ∏µÏàò",
    rooms: "Î∞©Ïàò",
    bathrooms: "ÌôîÏû•Ïã§Ïàò",
    parking: "Ï£ºÏ∞®Í∞ÄÎä•",
    elevator: "ÏóòÎ¶¨Î≤†Ïù¥ÌÑ∞",
    price: "Îß§Îß§Í∞Ä",
    deposit: "Î≥¥Ï¶ùÍ∏à",
    monthly_rent: "ÏõîÏÑ∏",
    maintenance_fee: "Í¥ÄÎ¶¨ÎπÑ",
    landlord_name: "ÏûÑÎåÄÏù∏Î™Ö",
    landlord_phone: "ÏûÑÎåÄÏù∏ Ïó∞ÎùΩÏ≤ò",
    landlord_email: "ÏûÑÎåÄÏù∏ Ïù¥Î©îÏùº",
    exit_date: "Ìá¥Ïã§ÎÇ†Ïßú",
    available_from: "ÏûÖÏ£ºÍ∞ÄÎä•Ïùº",
    description: "ÏÑ§Î™Ö",
    view_count: "Ï°∞ÌöåÏàò",
    inquiry_count: "Î¨∏ÏùòÏàò",
    created_at: "Îì±Î°ùÏùº",
    updated_at: "ÏàòÏ†ïÏùº",
  };

  interface ExportItem {
    [key: string]: string | number | boolean | Date;
  }

  const exportData = properties.map((property) => {
    const exportItem: ExportItem = {};
    includeFields.forEach((field) => {
      const label = fieldLabels[field] || field;
      exportItem[label] = formatFieldValue(property, field);
    });
    return exportItem;
  });

  return JSON.stringify(
    {
      exportDate: new Date().toISOString(),
      totalRecords: exportData.length,
      data: exportData,
    },
    null,
    2,
  );
};

/**
 * ÌïÑÎìú Í∞í Ìè¨Îß∑ÌåÖ
 */
const formatFieldValue = (
  property: Property,
  fieldId: string,
): string | number | boolean => {
  const value = property[fieldId as keyof Property];

  if (value === null || value === undefined) {
    return "";
  }

  switch (fieldId) {
    case "parking":
    case "elevator":
      return typeof value === "boolean" ? (value ? "ÏûàÏùå" : "ÏóÜÏùå") : "";

    case "price":
    case "deposit":
    case "monthly_rent":
    case "maintenance_fee":
      return typeof value === "number" ? value.toLocaleString() : "";

    case "created_at":
    case "updated_at":
    case "exit_date":
    case "available_from":
      return typeof value === "string"
        ? new Date(value).toLocaleDateString("ko-KR")
        : "";

    default:
      // Î≥µÏû°Ìïú ÌÉÄÏûÖ(Î∞∞Ïó¥, Í∞ùÏ≤¥)ÏùÄ Î¨∏ÏûêÏó¥Î°ú Î≥ÄÌôò
      if (typeof value === "object" && value !== null) {
        return Array.isArray(value) ? value.join(", ") : JSON.stringify(value);
      }
      return typeof value === "string" ||
        typeof value === "number" ||
        typeof value === "boolean"
        ? value
        : String(value);
  }
};

/**
 * Îß§Î¨º Îç∞Ïù¥ÌÑ∞ Í≤ÄÏ¶ù
 */
const validatePropertyData = (
  data: CreatePropertyData,
  row: number,
): ImportError | null => {
  const requiredFields = [
    "title",
    "type",
    "transaction_type",
    "address",
    "area",
    "floor",
    "total_floors",
    "rooms",
    "bathrooms",
  ];

  for (const field of requiredFields) {
    const value = data[field as keyof CreatePropertyData];
    if (value === undefined || value === null || value === "") {
      return {
        row,
        field,
        message: `ÌïÑÏàò ÌïÑÎìú '${field}'Í∞Ä ÎàÑÎùΩÎêòÏóàÏäµÎãàÎã§.`,
      };
    }
  }

  // Ïà´Ïûê ÌïÑÎìú Í≤ÄÏ¶ù
  const numericFields: (keyof CreatePropertyData)[] = [
    "area",
    "floor",
    "total_floors",
    "rooms",
    "bathrooms",
    "price",
    "deposit",
    "monthly_rent",
  ];
  for (const field of numericFields) {
    const value = data[field];
    if (value !== undefined && value !== null && value !== "") {
      if (typeof value !== "number" || isNaN(value) || value < 0) {
        return {
          row,
          field,
          message: `'${field}'Îäî Ïú†Ìö®Ìïú ÏñëÏàòÏó¨Ïïº Ìï©ÎãàÎã§.`,
        };
      }
    }
  }

  // Îß§Î¨º Ïú†Ìòï Í≤ÄÏ¶ù
  const validPropertyTypes = [
    "ÏïÑÌååÌä∏",
    "Ïò§ÌîºÏä§ÌÖî",
    "ÏõêÎ£∏",
    "ÎπåÎùº",
    "Îã®ÎèÖÏ£ºÌÉù",
    "ÏÉÅÍ∞Ä",
    "ÏÇ¨Î¨¥Ïã§",
    "Í∏∞ÌÉÄ",
  ];
  if (!validPropertyTypes.includes(data.type)) {
    return {
      row,
      field: "type",
      message: `Îß§Î¨º Ïú†ÌòïÏùÄ Îã§Ïùå Ï§ë ÌïòÎÇòÏó¨Ïïº Ìï©ÎãàÎã§: ${validPropertyTypes.join(", ")}`,
    };
  }

  // Í±∞Îûò Ïú†Ìòï Í≤ÄÏ¶ù
  const validTransactionTypes = ["Îß§Îß§", "Ï†ÑÏÑ∏", "ÏõîÏÑ∏", "Îã®Í∏∞ÏûÑÎåÄ"];
  if (!validTransactionTypes.includes(data.transaction_type)) {
    return {
      row,
      field: "transaction_type",
      message: `Í±∞Îûò Ïú†ÌòïÏùÄ Îã§Ïùå Ï§ë ÌïòÎÇòÏó¨Ïïº Ìï©ÎãàÎã§: ${validTransactionTypes.join(", ")}`,
    };
  }

  // ÎÇ†Ïßú ÌòïÏãù Í≤ÄÏ¶ù
  if (data.exit_date) {
    const date = new Date(data.exit_date);
    if (isNaN(date.getTime())) {
      return {
        row,
        field: "exit_date",
        message: `Ìá¥Ïã§ÎÇ†ÏßúÎäî Ïú†Ìö®Ìïú ÎÇ†Ïßú ÌòïÏãùÏù¥Ïñ¥Ïïº Ìï©ÎãàÎã§. (Ïòà: 2024-12-31)`,
      };
    }
  }

  return null;
};

/**
 * ÌååÏùº ÌÅ¨Í∏∞ Í≤ÄÏ¶ù
 */
export const validateFileSize = (
  file: File,
  maxSizeMB: number = 10,
): boolean => {
  const maxSizeBytes = maxSizeMB * 1024 * 1024;
  return file.size <= maxSizeBytes;
};

/**
 * ÌååÏùº ÌòïÏãù Í≤ÄÏ¶ù
 */
export const validateFileFormat = (file: File): boolean => {
  const allowedTypes = [
    "text/csv",
    "application/vnd.ms-excel",
    "text/tab-separated-values",
  ];
  const allowedExtensions = [".csv", ".tsv", ".txt"];

  return (
    allowedTypes.includes(file.type) ||
    allowedExtensions.some((ext) => file.name.toLowerCase().endsWith(ext))
  );
};

/**
 * ÌÖúÌîåÎ¶ø CSV ÏÉùÏÑ±
 */
export const generateTemplateCSV = (): string => {
  const headers = [
    "Îß§Î¨ºÎ™Ö",
    "Îß§Î¨ºÏú†Ìòï",
    "Í±∞ÎûòÏú†Ìòï",
    "Ï£ºÏÜå",
    "ÏÉÅÏÑ∏Ï£ºÏÜå",
    "Î©¥Ï†Å",
    "Ï∏µ",
    "Ï¥ùÏ∏µÏàò",
    "Î∞©Ïàò",
    "ÌôîÏû•Ïã§Ïàò",
    "Ï£ºÏ∞®",
    "ÏóòÎ¶¨Î≤†Ïù¥ÌÑ∞",
    "Îß§Îß§Í∞Ä",
    "Î≥¥Ï¶ùÍ∏à",
    "ÏõîÏÑ∏",
    "ÏûÑÎåÄÏù∏Î™Ö",
    "Ïó∞ÎùΩÏ≤ò",
    "Ìá¥Ïã§Ïùº",
    "ÏÑ§Î™Ö",
  ];

  const sampleData = [
    "Í∞ïÎÇ® Ïã†Ï∂ï ÏïÑÌååÌä∏",
    "ÏïÑÌååÌä∏",
    "Ï†ÑÏÑ∏",
    "ÏÑúÏö∏Ïãú Í∞ïÎÇ®Íµ¨ Ïó≠ÏÇºÎèô",
    "123-45",
    "84.5",
    "15",
    "25",
    "3",
    "2",
    "ÏûàÏùå",
    "ÏûàÏùå",
    "",
    "50000",
    "",
    "ÌôçÍ∏∏Îèô",
    "010-1234-5678",
    "2024-12-31",
    "Ïó≠ÏÑ∏Í∂å 3Î∂ÑÍ±∞Î¶¨ Ïã†Ï∂ïÏïÑÌååÌä∏",
  ];

  return [headers, sampleData]
    .map((row) => row.map((cell) => `"${cell}"`).join(","))
    .join("\n");
};
